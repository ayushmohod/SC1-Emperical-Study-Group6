{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity ^0.4.25;\r\n\r\ncontract FastGameMultiplier {\r\n\r\n    //\u0430\u0434\u0440\u0435\u0441 \u043f\u043e\u0434\u0434\u0435\u0440\u0436\u043a\u0438\r\n    address public support;\r\n\r\n    //\u041f\u0440\u043e\u0446\u0435\u043d\u0442\u044b\r\n\tuint constant public PRIZE_PERCENT = 3;\r\n    uint constant public SUPPORT_PERCENT = 2;\r\n    \r\n    //\u043e\u0433\u0440\u0430\u043d\u0438\u0447\u0435\u043d\u0438\u044f \u0434\u0435\u043f\u043e\u0437\u0438\u0442\u0430\r\n    uint constant public MAX_INVESTMENT =  0.2 ether;\r\n    uint constant public MIN_INVESTMENT = 0.01 ether;\r\n    uint constant public MIN_INVESTMENT_FOR_PRIZE = 0.02 ether;\r\n    uint constant public GAS_PRICE_MAX = 20; // \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u0430\u044f \u0446\u0435\u043d\u0430 \u0433\u0430\u0437\u0430 maximum gas price for contribution transactions\r\n    uint constant public MAX_IDLE_TIME = 10 minutes; //\u0432\u0440\u0435\u043c\u044f \u043e\u0436\u0438\u0434\u0430\u043d\u0438\u044f \u0434\u043e \u0437\u0430\u0431\u043e\u0440\u0430 \u043f\u0440\u0438\u0437\u0430 //Maximum time the deposit should remain the last to receive prize\r\n\r\n    //\u0443\u0441\u043f\u0435\u0448\u043d\u043e\u0441\u0442\u044c \u0438\u0433\u0440\u044b, \u043c\u0438\u043d\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0443\u0447\u0430\u0441\u0442\u043d\u0438\u043a\u043e\u0432\r\n    uint constant public SIZE_TO_SAVE_INVEST = 10; //\u043c\u0438\u043d\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0443\u0447\u0430\u0441\u0442\u043d\u0438\u043a\u043e\u0432\r\n    uint constant public TIME_TO_SAVE_INVEST = 5 minutes; //\u0432\u0440\u0435\u043c\u044f \u043f\u043e\u0441\u043b\u0435 \u043a\u043e\u0442\u043e\u0440\u043e\u0433\u043e \u0438\u0433\u0440\u0443 \u043c\u043e\u0436\u043d\u043e \u043e\u0442\u043c\u0435\u043d\u0438\u0442\u044c\r\n    \r\n    //\u0441\u0435\u0442\u043a\u0430 \u043f\u0440\u043e\u0446\u0435\u043d\u0442\u043e\u0432 \u0434\u043b\u044f \u0432\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u0432 \u043e\u0434\u043d\u043e\u043c \u0441\u0442\u0430\u0440\u0442\u0435, \u0441\u0442\u0430\u0440\u0442 \u043a\u0430\u0436\u0434\u044b\u0439 \u0447\u0430\u0441 (\u0442\u0435\u0441\u0442\u043e\u0432\u043e)\r\n    uint8[] MULTIPLIERS = [\r\n        115, //\u043f\u0435\u0440\u0432\u044b\u0439\r\n        120, //\u0432\u0442\u043e\u0440\u043e\u0439\r\n        125 //\u0442\u0440\u0435\u0442\u0438\u0439\r\n    ];\r\n\r\n    //\u043e\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u0434\u0435\u043f\u043e\u0437\u0438\u0442\u0430\r\n    struct Deposit {\r\n        address depositor; //\u0410\u0434\u0440\u0435\u0441 \u0434\u0435\u043f\u043e\u0437\u0438\u0442\u0430\r\n        uint128 deposit;   //\u0421\u0443\u043c\u043c\u0430 \u0434\u0435\u043f\u043e\u0437\u0438\u0442\u0430 \r\n        uint128 expect;    //\u0421\u043a\u043e\u043b\u044c\u043a\u043e \u0432\u044b\u043f\u043b\u0430\u0442\u0438\u0442\u044c \u043f\u043e \u0434\u0435\u043f\u043e\u0437\u0438\u0442\u0443 (115%-125%)\r\n    }\r\n\r\n   //\u041e\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u043d\u043e\u043c\u0435\u0440\u0430 \u043e\u0447\u0435\u0440\u0435\u0434\u0438 \u0438 \u043d\u043e\u043c\u0435\u0440 \u0434\u0435\u043f\u043e\u0437\u0438\u0442\u0430 \u0432 \u043e\u0447\u0435\u0440\u0435\u0434\u0438\r\n    struct DepositCount {\r\n        int128 stage;\r\n        uint128 count;\r\n    }\r\n\r\n\t//\u041e\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u043f\u043e\u0441\u043b\u0435\u0434\u043d\u0435\u0433\u043e \u0438 \u043f\u0440\u0435\u0434\u043f\u043e\u0441\u043b\u0435\u0434\u043d\u0435\u0433\u043e \u0434\u0435\u043f\u043e\u0437\u0438\u0442\u0430 \r\n    struct LastDepositInfo {\r\n        uint128 index;\r\n        uint128 time;\r\n    }\r\n\r\n    Deposit[] private queue;  //The queue\r\n\r\n    uint public currentReceiverIndex = 0; //\u0418\u043d\u0434\u0435\u043a\u0441 \u043f\u0435\u0440\u0432\u043e\u0433\u043e \u0438\u043d\u0432\u0435\u0441\u0442\u043e\u0440\u0430 The index of the first depositor in the queue. The receiver of investments!\r\n    uint public currentQueueSize = 0; //\u0420\u0430\u0437\u043c\u0435\u0440 \u043e\u0447\u0435\u0440\u0435\u0434\u0438 The current size of queue (may be less than queue.length)\r\n    LastDepositInfo public lastDepositInfoForPrize; //\u041f\u043e\u0441\u043b\u0435\u0434\u043d\u0438\u0439 \u0434\u0435\u043f\u043e\u0437\u0438\u0442 \u0434\u043b\u044f \u0414\u0436\u0435\u043a\u0430 The time last deposit made at\r\n    LastDepositInfo public previosDepositInfoForPrize; //\u041f\u0440\u0435\u0434\u043f\u043e\u0441\u043b\u0435\u0434\u043d\u0438\u0439 \u0434\u0435\u043f\u043e\u0437\u0438\u0442 \u0434\u043b\u044f \u0414\u0436\u0435\u043a\u0430 The time last deposit made at\r\n\r\n    uint public prizeAmount = 0; //\u0421\u0443\u043c\u043c\u0430 \u043f\u0440\u0438\u0437\u0430 \u043e\u0441\u0442\u0430\u0432\u0448\u0430\u044f\u0441\u044f \u0441 \u043f\u0440\u043e\u0448\u043b\u043e\u0433\u043e \u0437\u0430\u043f\u0443\u0441\u043a\u0430\r\n    uint public prizeStageAmount = 0; //\u0421\u0443\u043c\u043c\u0430 \u043f\u0440\u0438\u0437\u0430 Prize \u0432 \u0442\u0435\u043a\u0443\u0449\u0435\u043c \u0437\u0430\u043f\u0443\u0441\u043a\u0435 amount accumulated for the last depositor\r\n    int public stage = 0; //\u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0441\u0442\u0430\u0440\u0442\u043e\u0432 Number of contract runs\r\n    uint128 public lastDepositTime = 0; //\u0412\u0440\u0435\u043c\u044f \u043f\u043e\u0441\u043b\u0435\u0434\u043d\u0435\u0433\u043e \u0434\u0435\u043f\u043e\u0437\u0438\u0442\u0430\r\n    \r\n    mapping(address => DepositCount) public depositsMade; //The number of deposits of different depositors\r\n\r\n    constructor() public {\r\n        support = msg.sender; \r\n        proceedToNewStage(getCurrentStageByTime() + 1);\r\n    }\r\n    \r\n    //This function receives all the deposits\r\n    //stores them and make immediate payouts\r\n    function () public payable {\r\n        require(tx.gasprice <= GAS_PRICE_MAX * 1000000000);\r\n        require(gasleft() >= 250000, \"We require more gas!\"); //\u0443\u0441\u043b\u043e\u0432\u0438\u0435 \u043e\u0433\u0440\u0430\u043d\u0438\u0447\u0435\u043d\u0438\u044f \u0433\u0430\u0437\u0430\r\n        \r\n        checkAndUpdateStage();\r\n        \r\n        if(msg.value > 0){\r\n            require(msg.value >= MIN_INVESTMENT && msg.value <= MAX_INVESTMENT); //\u0423\u0441\u043b\u043e\u0432\u0438\u0435  \u0434\u0435\u043f\u043e\u0437\u0438\u0442\u0430\r\n            require(lastDepositInfoForPrize.time <= now + MAX_IDLE_TIME); \r\n\r\n            \r\n\r\n            require(getNextStageStartTime() >= now + MAX_IDLE_TIME + 10 minutes);//\u043d\u0435\u043b\u044c\u0437\u044f \u0438\u043d\u0432\u0435\u0441\u0442\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0437\u0430 MAX_IDLE_TIME \u0434\u043e \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0435\u0433\u043e \u0441\u0442\u0430\u0440\u0442\u0430\r\n\r\n            //Pay to first investors in line\r\n            if(currentQueueSize < SIZE_TO_SAVE_INVEST){ //\u0441\u0442\u0440\u0430\u0445\u043e\u0432\u043a\u0430 \u043e\u0442 \u043f\u043b\u043e\u0445\u043e\u0433\u043e \u0441\u0442\u0430\u0440\u0442\u0430\r\n                \r\n                addDeposit(msg.sender, msg.value);\r\n                \r\n            } else {\r\n                \r\n                addDeposit(msg.sender, msg.value);\r\n                pay(); \r\n                \r\n            }\r\n            \r\n        } else if(msg.value == 0 && currentQueueSize > SIZE_TO_SAVE_INVEST){\r\n            \r\n            withdrawPrize(); //\u0432\u044b\u043f\u043b\u0430\u0442\u0430 \u043f\u0440\u0438\u0437\u0430\r\n            \r\n        } else if(msg.value == 0){\r\n            \r\n            require(currentQueueSize <= SIZE_TO_SAVE_INVEST); //\u0414\u043b\u044f \u0432\u043e\u0437\u0432\u0440\u0430\u0442\u0430 \u0434\u043e\u043b\u0436\u043d\u043e \u0431\u044b\u0442\u044c \u043c\u0435\u043d\u0435\u0435, \u043b\u0438\u0431\u043e \u0440\u0430\u0432\u043d\u043e SIZE_TO_SAVE_INVEST \u0438\u0433\u0440\u043e\u043a\u043e\u0432\r\n            require(lastDepositTime > 0 && (now - lastDepositTime) >= TIME_TO_SAVE_INVEST); //\u0414\u043b\u044f \u0432\u043e\u0437\u0432\u0440\u0430\u0442\u0430 \u0434\u043e\u043b\u0436\u043d\u043e \u043f\u0440\u043e\u0439\u0442\u0438 \u0432\u0440\u0435\u043c\u044f TIME_TO_SAVE_INVEST\r\n            \r\n            returnPays(); //\u0412\u0435\u0440\u043d\u0443\u0442\u044c \u0432\u0441\u0435 \u0434\u0435\u043f\u043e\u0437\u0438\u0442\u044b\r\n            \r\n        } \r\n    }\r\n\r\n    //Used to pay to current investors\r\n    function pay() private {\r\n        //Try to send all the money on contract to the first investors in line\r\n        uint balance = address(this).balance;\r\n        uint128 money = 0;\r\n        \r\n        if(balance > prizeStageAmount) //The opposite is impossible, however the check will not do any harm\r\n            money = uint128(balance - prizeStageAmount);\r\n\r\n        //Send small part to tech support\r\n        uint128 moneyS = uint128(money*SUPPORT_PERCENT/100);\r\n        support.send(moneyS);\r\n        money -= moneyS;\r\n        \r\n        //We will do cycle on the queue\r\n        for(uint i=currentReceiverIndex; i<currentQueueSize; i++){\r\n\r\n            Deposit storage dep = queue[i]; //get the info of the first investor\r\n\r\n            if(money >= dep.expect){  //If we have enough money on the contract to fully pay to investor\r\n                    \r\n                dep.depositor.send(dep.expect); \r\n                money -= dep.expect;          \r\n                \r\n                //\u041f\u043e\u0441\u043b\u0435 \u0432\u044b\u043f\u043b\u0430\u0442\u044b \u0434\u0435\u043f\u043e\u0437\u0438\u0442\u044b + \u043f\u0440\u043e\u0446\u0435\u043d\u0442\u0430 \u0443\u0434\u0430\u043b\u044f\u0435\u0442\u0441\u044f \u0438\u0437 \u043e\u0447\u0435\u0440\u0435\u0434\u0438 this investor is fully paid, so remove him\r\n                delete queue[i];\r\n            \r\n                \r\n            }else{\r\n                //Here we don't have enough money so partially pay to investor\r\n\r\n                dep.depositor.send(money);      //Send to him everything we have\r\n                money -= dep.expect;            //update money left\r\n\r\n                break;                     //Exit cycle\r\n            }\r\n\r\n            if(gasleft() <= 50000)         //Check the gas left. If it is low, exit the cycle\r\n                break;                     //The next investor will process the line further\r\n        }\r\n\r\n        currentReceiverIndex = i; //Update the index of the current first investor\r\n    }\r\n    \r\n    function returnPays() private {\r\n        //Try to send all the money on contract to the first investors in line\r\n        uint balance = address(this).balance;\r\n        uint128 money = 0;\r\n        \r\n        if(balance > prizeAmount) //The opposite is impossible, however the check will not do any harm\r\n            money = uint128(balance - prizeAmount);\r\n        \r\n        //We will do cycle on the queue\r\n        for(uint i=currentReceiverIndex; i<currentQueueSize; i++){\r\n\r\n            Deposit storage dep = queue[i]; //get the info of the first investor\r\n\r\n                dep.depositor.send(dep.deposit); //\u0418\u0433\u0440\u0430 \u043d\u0435 \u0441\u043e\u0441\u0442\u043e\u044f\u043b\u0430\u0441\u044c, \u0432\u043e\u0437\u0432\u0440\u0430\u0442\r\n                money -= dep.deposit;            \r\n                \r\n                //\u041f\u043e\u0441\u043b\u0435 \u0432\u044b\u043f\u043b\u0430\u0442\u044b \u0434\u0435\u043f\u043e\u0437\u0438\u0442\u044b + \u043f\u0440\u043e\u0446\u0435\u043d\u0442\u0430 \u0443\u0434\u0430\u043b\u044f\u0435\u0442\u0441\u044f \u0438\u0437 \u043e\u0447\u0435\u0440\u0435\u0434\u0438 this investor is fully paid, so remove him\r\n                delete queue[i];\r\n\r\n        }\r\n\r\n        prizeStageAmount = 0; //\u0412\u0435\u0440\u043d\u0443\u043b\u0438 \u0434\u0435\u043d\u044c\u0433\u0438, \u0434\u0436\u0435\u043a\u0430 \u0442\u0435\u043a\u0443\u0449\u0435\u0439 \u043e\u0447\u0435\u0440\u0435\u0434\u0438 \u043d\u0435\u0442.\r\n        proceedToNewStage(getCurrentStageByTime() + 1);\r\n    }\r\n\r\n    function addDeposit(address depositor, uint value) private {\r\n        //Count the number of the deposit at this stage\r\n        DepositCount storage c = depositsMade[depositor];\r\n        if(c.stage != stage){\r\n            c.stage = int128(stage);\r\n            c.count = 0;\r\n        }\r\n\r\n        //\u0423\u0447\u0430\u0441\u0442\u0438\u0435 \u0432 \u0438\u0433\u0440\u0435 \u0437\u0430 \u0434\u0436\u0435\u043a\u043f\u043e\u0442 \u0442\u043e\u043b\u044c\u043a\u043e \u043c\u0438\u043d\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u043c \u0434\u0435\u043f\u043e\u0437\u0438\u0442\u0435 MIN_INVESTMENT_FOR_PRIZE\r\n        if(value >= MIN_INVESTMENT_FOR_PRIZE){\r\n            previosDepositInfoForPrize = lastDepositInfoForPrize;\r\n            lastDepositInfoForPrize = LastDepositInfo(uint128(currentQueueSize), uint128(now));\r\n        }\r\n\r\n        //Compute the multiplier percent for this depositor\r\n        uint multiplier = getDepositorMultiplier(depositor);\r\n        \r\n        push(depositor, value, value*multiplier/100);\r\n\r\n        //Increment number of deposits the depositors made this round\r\n        c.count++;\r\n\r\n        lastDepositTime = uint128(now);\r\n        \r\n        //Save money for prize\r\n        prizeStageAmount += value*PRIZE_PERCENT/100;\r\n    }\r\n\r\n    function checkAndUpdateStage() private {\r\n        int _stage = getCurrentStageByTime();\r\n\r\n        require(_stage >= stage); //\u0441\u0442\u0430\u0440\u0442 \u0435\u0449\u0435 \u043d\u0435 \u043f\u0440\u043e\u0438\u0437\u043e\u0448\u0435\u043b\r\n\r\n        if(_stage != stage){\r\n            proceedToNewStage(_stage);\r\n        }\r\n    }\r\n\r\n    function proceedToNewStage(int _stage) private {\r\n        //\u0421\u0442\u0430\u0440\u0442 \u043d\u043e\u0432\u043e\u0439 \u0438\u0433\u0440\u044b\r\n        stage = _stage;\r\n        currentQueueSize = 0; \r\n        currentReceiverIndex = 0;\r\n        lastDepositTime = 0;\r\n        prizeAmount += prizeStageAmount; \r\n        prizeStageAmount = 0;\r\n        delete queue;\r\n        delete previosDepositInfoForPrize;\r\n        delete lastDepositInfoForPrize;\r\n    }\r\n\r\n    //\u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0430 \u043f\u0440\u0438\u0437\u0430\r\n    function withdrawPrize() private {\r\n        //You can withdraw prize only if the last deposit was more than MAX_IDLE_TIME ago\r\n        require(lastDepositInfoForPrize.time > 0 && lastDepositInfoForPrize.time <= now - MAX_IDLE_TIME, \"The last depositor is not confirmed yet\");\r\n        //Last depositor will receive prize only if it has not been fully paid\r\n        require(currentReceiverIndex <= lastDepositInfoForPrize.index, \"The last depositor should still be in queue\");\r\n\r\n        uint balance = address(this).balance;\r\n\r\n        //Send donation to the first multiplier for it to spin faster\r\n        //It already contains all the sum, so we must split for father and last depositor only\r\n        //If the .call fails then ether will just stay on the contract to be distributed to\r\n        //the queue at the next stage\r\n\r\n        uint prize = balance;\r\n        if(previosDepositInfoForPrize.index > 0){\r\n            uint prizePrevios = prize*10/100;\r\n            queue[previosDepositInfoForPrize.index].depositor.transfer(prizePrevios);\r\n            prize -= prizePrevios;\r\n        }\r\n\r\n        queue[lastDepositInfoForPrize.index].depositor.send(prize);\r\n        \r\n        proceedToNewStage(getCurrentStageByTime() + 1);\r\n    }\r\n\r\n    //\u0414\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u0432\u044b\u043f\u043b\u0430\u0442\u0443 \u0432 \u043e\u0447\u0435\u0440\u0435\u0434\u044c\r\n    function push(address depositor, uint deposit, uint expect) private {\r\n        //Add the investor into the queue\r\n        Deposit memory dep = Deposit(depositor, uint128(deposit), uint128(expect));\r\n        assert(currentQueueSize <= queue.length); //Assert queue size is not corrupted\r\n        if(queue.length == currentQueueSize)\r\n            queue.push(dep);\r\n        else\r\n            queue[currentQueueSize] = dep;\r\n\r\n        currentQueueSize++;\r\n    }\r\n\r\n    //\u0418\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044f \u043e \u0434\u0435\u043f\u043e\u0437\u0438\u0442\u0435\r\n    function getDeposit(uint idx) public view returns (address depositor, uint deposit, uint expect){\r\n        Deposit storage dep = queue[idx];\r\n        return (dep.depositor, dep.deposit, dep.expect);\r\n    }\r\n\r\n    //\u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0434\u0435\u043f\u043e\u0437\u0438\u0442\u043e\u0432 \u0432\u043d\u0435\u0441\u0435\u043d\u043d\u043e\u0435 \u0438\u0433\u0440\u043e\u043a\u043e\u043c\r\n    function getDepositsCount(address depositor) public view returns (uint) {\r\n        uint c = 0;\r\n        for(uint i=currentReceiverIndex; i<currentQueueSize; ++i){\r\n            if(queue[i].depositor == depositor)\r\n                c++;\r\n        }\r\n        return c;\r\n    }\r\n\r\n    //\u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0443\u0447\u0430\u0441\u0442\u043d\u0438\u043a\u043e\u0432 \u0438\u0433\u0440\u044b\r\n    function getQueueLength() public view returns (uint) {\r\n        return currentQueueSize - currentReceiverIndex;\r\n    }\r\n\r\n    //\u041d\u043e\u043c\u0435\u0440 \u0432\u043a\u043b\u0430\u0434\u0430 \u0432 \u0442\u0435\u043a\u0443\u0449\u0435\u0439 \u043e\u0447\u0435\u0440\u0435\u0434\u0438\r\n    function getDepositorMultiplier(address depositor) public view returns (uint) {\r\n        DepositCount storage c = depositsMade[depositor];\r\n        uint count = 0;\r\n        if(c.stage == getCurrentStageByTime())\r\n            count = c.count;\r\n        if(count < MULTIPLIERS.length)\r\n            return MULTIPLIERS[count];\r\n\r\n        return MULTIPLIERS[MULTIPLIERS.length - 1];\r\n    }\r\n\r\n    // \u0422\u0435\u043a\u0443\u0449\u0438\u0439 \u044d\u0442\u0430\u043f \u0438\u0433\u0440\u044b\r\n    function getCurrentStageByTime() public view returns (int) {\r\n        return int(now - 17848 * 86400 - 16 * 3600 - 30 * 60) / (24 * 60 * 60);\r\n    }\r\n\r\n    // \u0412\u0440\u0435\u043c\u044f \u043d\u0430\u0447\u0430\u043b\u0430 \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0435\u0439 \u0438\u0433\u0440\u044b\r\n    function getNextStageStartTime() public view returns (uint) {\r\n        return 17848 * 86400 + 16 * 3600 + 30 * 60 + uint((getCurrentStageByTime() + 1) * 24 * 60 * 60); //\u0441\u0442\u0430\u0440\u0442 19:30\r\n    }\r\n\r\n    //\u0418\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044f \u043e\u0431 \u043a\u0430\u043d\u0434\u0438\u0434\u0430\u0442\u0435 \u043d\u0430 \u043f\u0440\u0438\u0437\r\n    function getCurrentCandidateForPrize() public view returns (address addr, int timeLeft){\r\n        if(currentReceiverIndex <= lastDepositInfoForPrize.index && lastDepositInfoForPrize.index < currentQueueSize){\r\n            Deposit storage d = queue[lastDepositInfoForPrize.index];\r\n            addr = d.depositor;\r\n            timeLeft = int(lastDepositInfoForPrize.time + MAX_IDLE_TIME) - int(now);\r\n        }\r\n    }\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"getNextStageStartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentQueueSize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastDepositInfoForPrize\",\"outputs\":[{\"name\":\"index\",\"type\":\"uint128\"},{\"name\":\"time\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"support\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SUPPORT_PERCENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentStageByTime\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentReceiverIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"depositor\",\"type\":\"address\"}],\"name\":\"getDepositorMultiplier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"GAS_PRICE_MAX\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_INVESTMENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_INVESTMENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"prizeAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PRIZE_PERCENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_INVESTMENT_FOR_PRIZE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"idx\",\"type\":\"uint256\"}],\"name\":\"getDeposit\",\"outputs\":[{\"name\":\"depositor\",\"type\":\"address\"},{\"name\":\"deposit\",\"type\":\"uint256\"},{\"name\":\"expect\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"prizeStageAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"depositsMade\",\"outputs\":[{\"name\":\"stage\",\"type\":\"int128\"},{\"name\":\"count\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getQueueLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SIZE_TO_SAVE_INVEST\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastDepositTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stage\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"depositor\",\"type\":\"address\"}],\"name\":\"getDepositsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_IDLE_TIME\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TIME_TO_SAVE_INVEST\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentCandidateForPrize\",\"outputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"timeLeft\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"previosDepositInfoForPrize\",\"outputs\":[{\"name\":\"index\",\"type\":\"uint128\"},{\"name\":\"time\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]", "ContractName": "FastGameMultiplier", "CompilerVersion": "v0.4.25+commit.59dbf8f1", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://203fff6508dfb78c418cf0fe047cb50387d3977254db40e88364d8e44dc0bf5d"}]}