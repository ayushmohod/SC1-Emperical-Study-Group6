{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity ^0.4.24;\r\n\r\ncontract dapBetting {\r\n\r\n/* Types */\r\n\r\nenum eventStatus{ open, finished, closed }\r\n\r\nstruct bid{\r\nuint id;\r\nbytes32 name;\r\naddress[] whoBet;\r\nuint amountReceived;\r\n}\r\n\r\nstruct betEvent{\r\nuint id;\r\nbytes32 name;\r\naddress creator;\r\naddress arbitrator;\r\nbytes32 winner;\r\nuint arbitratorFee;\r\nuint256 endBlock;\r\nuint256 minBid;\r\nuint256 maxBid;\r\nbid[] bids;\r\nbet[] bets;\r\neventStatus status;\r\n}\r\n\r\nstruct bet{\r\naddress person;\r\nbytes32 bidName;\r\nuint amount;\r\n}\r\n\r\n/* Storage */\r\n\r\nmapping (address => betEvent[]) public betEvents;\r\nmapping (address => uint) public pendingWithdrawals;\r\n\r\n/* Events */\r\n\r\nevent eventCreated(uint id, address creator);\r\nevent betMade(uint value, uint id);\r\nevent eventStatusChanged(uint status);\r\nevent withdrawalDone(uint amount);\r\n\r\n/* Modifiers */\r\nmodifier onlyFinished(address creator, uint eventId){\r\nif (betEvents[creator][eventId].status == eventStatus.finished || betEvents[creator][eventId].endBlock < block.number){\r\n_;\r\n}\r\n}\r\nmodifier onlyArbitrator(address creator, uint eventId){\r\nif (betEvents[creator][eventId].arbitrator == msg.sender){\r\n_;\r\n}\r\n}\r\n/* Methods */\r\n\r\nfunction createEvent(bytes32 name, bytes32[] names, address arbitrator, uint fee, uint256 endBlock, uint256 minBid, uint256 maxBid) external{\r\n\r\nrequire(fee < 100);\r\n/* check whether event with such name already exist */\r\nbool found;\r\nfor (uint8 x = 0;x<betEvents[msg.sender].length;x++){\r\nif(betEvents[msg.sender][x].name == name){\r\nfound = true;\r\n}\r\n}\r\nrequire(!found);\r\n\r\n/* check names for duplicates */\r\nfor (uint8 y=0;i<names.length;i++){\r\nrequire(names[y] != names[y+1]);\r\n}\r\n\r\nuint newId = betEvents[msg.sender].length++;\r\nbetEvents[msg.sender][newId].id = newId;\r\nbetEvents[msg.sender][newId].name = name;\r\nbetEvents[msg.sender][newId].arbitrator = arbitrator;\r\nbetEvents[msg.sender][newId].status = eventStatus.open;\r\nbetEvents[msg.sender][newId].creator = msg.sender;\r\nbetEvents[msg.sender][newId].endBlock = endBlock;\r\nbetEvents[msg.sender][newId].minBid = minBid;\r\nbetEvents[msg.sender][newId].maxBid = maxBid;\r\nbetEvents[msg.sender][newId].arbitratorFee = fee;\r\n\r\nfor (uint8 i = 0;i < names.length; i++){\r\nuint newBidId = betEvents[msg.sender][newId].bids.length++;\r\nbetEvents[msg.sender][newId].bids[newBidId].name = names[i];\r\nbetEvents[msg.sender][newId].bids[newBidId].id = newBidId;\r\n}\r\n\r\nemit eventCreated(newId, msg.sender);\r\n}\r\n\r\nfunction makeBet(address creator, uint eventId, bytes32 bidName) payable external{\r\nrequire(betEvents[creator][eventId].status == eventStatus.open);\r\nif (betEvents[creator][eventId].endBlock > 0){\r\nrequire(block.number > betEvents[creator][eventId].endBlock);\r\n}\r\n/* check whether bid with given name actually exists */\r\nbool found;\r\nfor (uint8 i=0;i<betEvents[creator][eventId].bids.length;i++){\r\nif (betEvents[creator][eventId].bids[i].name == bidName){\r\nbid storage foundBid = betEvents[creator][eventId].bids[i];\r\nfound = true;\r\n}\r\n}\r\nrequire(found);\r\n//check for block\r\nif (betEvents[creator][eventId].endBlock > 0){\r\nrequire(betEvents[creator][eventId].endBlock < block.number);\r\n}\r\n//check for minimal amount\r\nif (betEvents[creator][eventId].minBid > 0){\r\nrequire(msg.value > betEvents[creator][eventId].minBid);\r\n}\r\n//check for maximal amount\r\nif (betEvents[creator][eventId].maxBid > 0){\r\nrequire(msg.value < betEvents[creator][eventId].maxBid);\r\n}\r\nfoundBid.whoBet.push(msg.sender);\r\nfoundBid.amountReceived += msg.value;\r\nuint newBetId = betEvents[creator][eventId].bets.length++;\r\nbetEvents[creator][eventId].bets[newBetId].person = msg.sender;\r\nbetEvents[creator][eventId].bets[newBetId].amount = msg.value;\r\nbetEvents[creator][eventId].bets[newBetId].bidName = bidName;\r\n\r\nemit betMade(msg.value, newBetId);\r\n}\r\n\r\nfunction finishEvent(address creator, uint eventId) external{\r\nrequire(betEvents[creator][eventId].status == eventStatus.open && betEvents[creator][eventId].endBlock == 0);\r\nrequire(msg.sender == betEvents[creator][eventId].arbitrator);\r\nbetEvents[creator][eventId].status = eventStatus.finished;\r\nemit eventStatusChanged(1);\r\n}\r\n\r\nfunction determineWinner(address creator, uint eventId, bytes32 bidName) external onlyFinished(creator, eventId) onlyArbitrator(creator, eventId){\r\nrequire (findBid(creator, eventId, bidName));\r\nbetEvent storage cEvent = betEvents[creator][eventId];\r\ncEvent.winner = bidName;\r\nuint amountLost;\r\nuint amountWon;\r\nuint lostBetsLen;\r\n/*Calculating amount of all lost bets */\r\nfor (uint x=0;x<betEvents[creator][eventId].bids.length;x++){\r\nif (cEvent.bids[x].name != cEvent.winner){\r\namountLost += cEvent.bids[x].amountReceived;\r\n}\r\n}\r\n\r\n/* Calculating amount of all won bets */\r\nfor (x=0;x<cEvent.bets.length;x++){\r\nif(cEvent.bets[x].bidName == cEvent.winner){\r\nuint wonBetAmount = cEvent.bets[x].amount;\r\namountWon += wonBetAmount;\r\npendingWithdrawals[cEvent.bets[x].person] += wonBetAmount;\r\n} else {\r\nlostBetsLen++;\r\n}\r\n}\r\n/* If we do have win bets */\r\nif (amountWon > 0){\r\npendingWithdrawals[cEvent.arbitrator] += amountLost/100*cEvent.arbitratorFee;\r\namountLost = amountLost - (amountLost/100*cEvent.arbitratorFee);\r\nfor (x=0;x<cEvent.bets.length;x++){\r\nif(cEvent.bets[x].bidName == cEvent.winner){\r\n//uint wonBetPercentage = cEvent.bets[x].amount*100/amountWon;\r\nuint wonBetPercentage = percent(cEvent.bets[x].amount, amountWon, 2);\r\npendingWithdrawals[cEvent.bets[x].person] += (amountLost/100)*wonBetPercentage;\r\n}\r\n}\r\n} else {\r\n/* If we dont have any bets won, we pay all the funds back except arbitrator fee */\r\nfor(x=0;x<cEvent.bets.length;x++){\r\npendingWithdrawals[cEvent.bets[x].person] += cEvent.bets[x].amount-((cEvent.bets[x].amount/100) * cEvent.arbitratorFee);\r\npendingWithdrawals[cEvent.arbitrator] += (cEvent.bets[x].amount/100) * cEvent.arbitratorFee;\r\n}\r\n}\r\ncEvent.status = eventStatus.closed;\r\nemit eventStatusChanged(2);\r\n}\r\n\r\nfunction withdraw(address person) private{\r\nuint amount = pendingWithdrawals[person];\r\npendingWithdrawals[person] = 0;\r\nperson.transfer(amount);\r\nemit withdrawalDone(amount);\r\n}\r\n\r\nfunction requestWithdraw() external {\r\n//require(pendingWithdrawals[msg.sender] != 0);\r\nwithdraw(msg.sender);\r\n}\r\n\r\nfunction findBid(address creator, uint eventId, bytes32 bidName) private view returns(bool){\r\nfor (uint8 i=0;i<betEvents[creator][eventId].bids.length;i++){\r\nif(betEvents[creator][eventId].bids[i].name == bidName){\r\nreturn true;\r\n}\r\n}\r\n}\r\n\r\nfunction calc(uint one, uint two) private pure returns(uint){\r\nreturn one/two;\r\n}\r\nfunction percent(uint numerator, uint denominator, uint precision) public\r\n\r\npure returns(uint quotient) {\r\n// caution, check safe-to-multiply here\r\nuint _numerator  = numerator * 10 ** (precision+1);\r\n// with rounding of last digit\r\nuint _quotient =  ((_numerator / denominator) + 5) / 10;\r\nreturn ( _quotient);\r\n}\r\n/* Getters */\r\n\r\nfunction getBidsNum(address creator, uint eventId) external view returns (uint){\r\nreturn betEvents[creator][eventId].bids.length;\r\n}\r\n\r\nfunction getBid(address creator, uint eventId, uint bidId) external view returns (uint, bytes32, uint){\r\nbid storage foundBid = betEvents[creator][eventId].bids[bidId];\r\nreturn(foundBid.id, foundBid.name, foundBid.amountReceived);\r\n}\r\n\r\nfunction getBetsNums(address creator, uint eventId) external view returns (uint){\r\nreturn betEvents[creator][eventId].bets.length;\r\n}\r\n\r\nfunction getWhoBet(address creator, uint eventId, uint bidId) external view returns (address[]){\r\nreturn betEvents[creator][eventId].bids[bidId].whoBet;\r\n}\r\n\r\nfunction getBet(address creator, uint eventId, uint betId) external view returns(address, bytes32, uint){\r\nbet storage foundBet = betEvents[creator][eventId].bets[betId];\r\nreturn (foundBet.person, foundBet.bidName, foundBet.amount);\r\n}\r\n\r\n/*\r\n* If you are reading this contract as example for creating custom dApps on dApp Builder platform,\r\n* pay attention, that you must add the same function to your smart contract,\r\n* but it must be named not getEventId, but getDappId\r\n*/\r\nfunction getEventId(address creator, bytes32 eventName) external view returns (uint, bool){\r\nfor (uint i=0;i<betEvents[creator].length;i++){\r\nif(betEvents[creator][i].name == eventName){\r\nreturn (betEvents[creator][i].id, true);\r\n}\r\n}\r\n}\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[{\"name\":\"numerator\",\"type\":\"uint256\"},{\"name\":\"denominator\",\"type\":\"uint256\"},{\"name\":\"precision\",\"type\":\"uint256\"}],\"name\":\"percent\",\"outputs\":[{\"name\":\"quotient\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"creator\",\"type\":\"address\"},{\"name\":\"eventId\",\"type\":\"uint256\"}],\"name\":\"getBidsNum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"creator\",\"type\":\"address\"},{\"name\":\"eventName\",\"type\":\"bytes32\"}],\"name\":\"getEventId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"creator\",\"type\":\"address\"},{\"name\":\"eventId\",\"type\":\"uint256\"},{\"name\":\"bidName\",\"type\":\"bytes32\"}],\"name\":\"determineWinner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"creator\",\"type\":\"address\"},{\"name\":\"eventId\",\"type\":\"uint256\"},{\"name\":\"bidName\",\"type\":\"bytes32\"}],\"name\":\"makeBet\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"creator\",\"type\":\"address\"},{\"name\":\"eventId\",\"type\":\"uint256\"}],\"name\":\"getBetsNums\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"creator\",\"type\":\"address\"},{\"name\":\"eventId\",\"type\":\"uint256\"},{\"name\":\"betId\",\"type\":\"uint256\"}],\"name\":\"getBet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"creator\",\"type\":\"address\"},{\"name\":\"eventId\",\"type\":\"uint256\"},{\"name\":\"bidId\",\"type\":\"uint256\"}],\"name\":\"getBid\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"creator\",\"type\":\"address\"},{\"name\":\"eventId\",\"type\":\"uint256\"},{\"name\":\"bidId\",\"type\":\"uint256\"}],\"name\":\"getWhoBet\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"requestWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"creator\",\"type\":\"address\"},{\"name\":\"eventId\",\"type\":\"uint256\"}],\"name\":\"finishEvent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"pendingWithdrawals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"betEvents\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"name\",\"type\":\"bytes32\"},{\"name\":\"creator\",\"type\":\"address\"},{\"name\":\"arbitrator\",\"type\":\"address\"},{\"name\":\"winner\",\"type\":\"bytes32\"},{\"name\":\"arbitratorFee\",\"type\":\"uint256\"},{\"name\":\"endBlock\",\"type\":\"uint256\"},{\"name\":\"minBid\",\"type\":\"uint256\"},{\"name\":\"maxBid\",\"type\":\"uint256\"},{\"name\":\"status\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"name\",\"type\":\"bytes32\"},{\"name\":\"names\",\"type\":\"bytes32[]\"},{\"name\":\"arbitrator\",\"type\":\"address\"},{\"name\":\"fee\",\"type\":\"uint256\"},{\"name\":\"endBlock\",\"type\":\"uint256\"},{\"name\":\"minBid\",\"type\":\"uint256\"},{\"name\":\"maxBid\",\"type\":\"uint256\"}],\"name\":\"createEvent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"creator\",\"type\":\"address\"}],\"name\":\"eventCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"betMade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"status\",\"type\":\"uint256\"}],\"name\":\"eventStatusChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawalDone\",\"type\":\"event\"}]", "ContractName": "dapBetting", "CompilerVersion": "v0.4.26+commit.4563c3fc", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://3778b1f979fa19109dbafbba9f3f75109428be2e160ddfe03b1f0b48681fb918"}]}